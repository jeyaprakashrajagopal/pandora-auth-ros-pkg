#include <Rs232.h>

Rs232::Rs232(void){
	//initialize mutex
	pthread_mutex_init(&portMutex,NULL);
	//initialize fd. fd==-1 means no port is open yet
	fd=-1;
}

Rs232::Rs232(std::string port,unsigned int baudRate,unsigned int timeout){
	//initialize mutex
	pthread_mutex_init(&portMutex,NULL);
	//initialize fd. fd==-1 means no port is open yet
	fd=-1;
	//attempt to open the port
	Rs232::open(port,baudRate,timeout);
	//if fd is not negative operation was succesfull. Otherwise an error
	//message will be generated by Rs232::open. No need to output anything
	//here
}

int Rs232::open(std::string port,unsigned int speed,int timeout){
	if(fd!=-1){
		//Port already open. Inform user and abort!
		std::cerr<<"error: Rs232: open: port already open, please use close before attempting a new open"<<std::endl;
		return -1;
	}
	//used to store the value of errno
	int error;
	//not all baud rates are valid. Do a validation check and inform the
	//user in the event of an error. Also use the OS defined values for
	//greater compatibility.
	switch(speed){
		case 115200: speed=B115200; break;
		case 57600: speed=B57600; break;
		case 38400: speed=B38400; break;
		case 19200: speed=B19200; break;
		case 9600: speed=B9600; break;
		case 4800: speed=B4800; break;
		case 2400: speed=B2400; break;
		case 1800: speed=B1800; break;
		case 1200: speed=B1200; break;
		case 600: speed=B600; break;
		case 300: speed=B300; break;
		case 200: speed=B200; break;
		case 150: speed=B150; break;
		case 134: speed=B134; break;
		case 110: speed=B110; break;
		case 75: speed=B75; break;
		case 50: speed=B50; break;
		default:
			std::cerr<<"error: Rs232: open: invalid port speed: "<<speed<<std::endl;
			std::cerr<<"\tvalid values are:\n";
			std::cerr<<"\t\t115200\n\t\t57600\n\t\t38400\n\t\t19200\n\t\t9600\n\t\t4800\n\t\t2400\n\t\t1800\n\t\t1200\n\t\t600\n\t\t300\n\t\t200\n\t\t150\n\t\t134\n\t\t110\n\t\t75\n\t\t50"<<std::endl;
			return -1;
	}
	//Lock mutex before openning port
	pthread_mutex_lock(&portMutex);
	//Open for read/write, not a control tty, blocking
	int newFd=::open(port.c_str(),O_RDWR | O_NOCTTY | O_SYNC);
	//store the errno as soon as posible
	error=errno;
	if(newFd == -1){
		//inform user, unlock mutex and return
		std::cerr<<"error: Rs232: cannot open port: "<<port<<": "<<strerror(error)<<std::endl;
		pthread_mutex_unlock(&portMutex);
		return -1;
	}
	//set all file descriptor flags to zero
	fcntl(newFd,F_SETFL,0);

	//load tty options for file descriptor
	struct termios options;  
	tcgetattr(newFd,&options);
	//set read/write speed
	cfsetispeed(&options,speed);
	cfsetospeed(&options,speed);
	
	options.c_cflag&=~PARENB; //no parity
	options.c_cflag&=~CSTOPB; //1 stop bit (ie not two)
	options.c_cflag&=~CRTSCTS; //no handshaking
	options.c_cflag&=~CSIZE; //bit size mask (ie clear all frame size bits before aplying CS8)
	options.c_cflag|=CS8; //8bit frame
	options.c_cflag|=CREAD; //Enable reader
	options.c_cflag|=CLOCAL; //do not change owner of port
	
	options.c_oflag&=~OPOST; //disable post processesing of data (raw binary mode)
	options.c_oflag&=~ONLCR; //do not map NL to CR-NL
	options.c_cc[VMIN]=0; //minimum characters to read is 0 (ie enable timeout)
	options.c_cc[VTIME]=timeout/100; //timeout in tenths of seconds

/*
What Is a Break?

Normally a receive or transmit data signal stays at the mark voltage
until a new character is transferred. If the signal is dropped to the
space voltage for a long period of time, usually 1/4 to 1/2 second, then
a break condition is said to exist.
*/
	options.c_iflag|=IGNBRK; //ignore break condition
	options.c_iflag&=~IGNCR; //ignore CR
	
	options.c_lflag&=~ICANON; //disable canonical input (ie use raw input)
	options.c_lflag&=~ECHO; //disable echo
	options.c_lflag&=~ECHOE; //disable echoing of erase characters (ie BS DEL)
	options.c_lflag&=~ISIG; //disable interupt signals

	options.c_iflag&=~IXON; //disable software flow control (outgoing)
	options.c_iflag&=~IXOFF; //disable software (incomming)
	options.c_iflag&=~IXANY; //disable any character to start flow control

	tcsetattr(newFd,TCSANOW,&options); //set options to serial port now
	fd=newFd;
	pthread_mutex_unlock(&portMutex); //unlock mutex
	return newFd; //return the file descriptor
}

int Rs232::close(void){
	if(fd==-1){
		std::cerr<<"warning: Rs232: close: port already closed"<<std::endl;
		return 0;
	}
	pthread_mutex_lock(&portMutex);
	int ret=::close(fd);
	pthread_mutex_unlock(&portMutex);
	return ret;
}

int Rs232::write(char data){
	char arrayData[1];
	arrayData[0]=data;
	return write(&arrayData[0],1);
}

int Rs232::write(char *data,unsigned int size){
	int error;
	if(fd==-1){
			std::cerr<<"error: Rs232: send: cannot send data: port closed"<<std::endl;
			return -1;
	}
	
	
	pthread_mutex_lock(&portMutex);
	unsigned int bytesSent=0;
	while(bytesSent<size){
		int n=::write(fd,&data[bytesSent],size-bytesSent);
		error=errno;
		if(n>0) bytesSent+=n;
		else if(n<0){
			std::cerr<<"error: Rs232: send: "<<strerror(error)<<std::endl;
			pthread_mutex_unlock(&portMutex);
			return n;
		}else{
			std::cerr<<"error: Rs232: send: zero bytes were written to port!"<<std::endl;
			pthread_mutex_lock(&portMutex);
			return n;
		}
	}
	pthread_mutex_unlock(&portMutex);
	return bytesSent;
}

int Rs232::read(char& data){
	char arrayData[1];
	int ret=read(&arrayData[0],1);
	if(ret==1) data=arrayData[0];
	return ret;
}

int Rs232::read(char *data,unsigned int size){
	if(fd==-1){
			std::cerr<<"error: Rs232: read: cannot read data, port closed"<<std::endl;
			return -1;
	}
	pthread_mutex_lock(&portMutex);
	unsigned int bytesReceived=0;
	while(bytesReceived<size){
		int n=::read(fd,&data[bytesReceived],size-bytesReceived);
		if(n>0)	bytesReceived+=n;
		else if(n<0){
			int error=errno;
			std::cerr<<"error: Rs232: "<<strerror(error)<<std::endl;
			pthread_mutex_unlock(&portMutex);
			return n;
		}
		else{
			pthread_mutex_unlock(&portMutex);
			return n;
		}
	}
	pthread_mutex_unlock(&portMutex);
	return bytesReceived;
}

void Rs232::forceUnlock(void){
	pthread_mutex_unlock(&portMutex);	
}

